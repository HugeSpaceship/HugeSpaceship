// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Game string

const (
	GameLBP1   Game = "LBP1"
	GameLBPPSP Game = "LBPPSP"
	GameLBP2   Game = "LBP2"
	GameLBPV   Game = "LBPV"
	GameLBP3   Game = "LBP3"
	GameWeb    Game = "Web"
)

func (e *Game) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Game(s)
	case string:
		*e = Game(s)
	default:
		return fmt.Errorf("unsupported scan type for Game: %T", src)
	}
	return nil
}

type NullGame struct {
	Game  Game
	Valid bool // Valid is true if Game is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGame) Scan(value interface{}) error {
	if value == nil {
		ns.Game, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Game.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGame) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Game), nil
}

type NatType string

const (
	NatTypeOpen     NatType = "open"
	NatTypeModerate NatType = "moderate"
	NatTypeStrict   NatType = "strict"
)

func (e *NatType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NatType(s)
	case string:
		*e = NatType(s)
	default:
		return fmt.Errorf("unsupported scan type for NatType: %T", src)
	}
	return nil
}

type NullNatType struct {
	NatType NatType
	Valid   bool // Valid is true if NatType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNatType) Scan(value interface{}) error {
	if value == nil {
		ns.NatType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NatType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNatType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NatType), nil
}

type OverrideType string

const (
	OverrideTypeALLOW    OverrideType = "ALLOW"
	OverrideTypeDENY     OverrideType = "DENY"
	OverrideTypeEXTERNAL OverrideType = "EXTERNAL"
)

func (e *OverrideType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OverrideType(s)
	case string:
		*e = OverrideType(s)
	default:
		return fmt.Errorf("unsupported scan type for OverrideType: %T", src)
	}
	return nil
}

type NullOverrideType struct {
	OverrideType OverrideType
	Valid        bool // Valid is true if OverrideType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOverrideType) Scan(value interface{}) error {
	if value == nil {
		ns.OverrideType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OverrideType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOverrideType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OverrideType), nil
}

type Platform string

const (
	PlatformPS3     Platform = "PS3"
	PlatformPSP     Platform = "PSP"
	PlatformPSVita  Platform = "PSVita"
	PlatformPS4     Platform = "PS4"
	PlatformRPCS3   Platform = "RPCS3"
	PlatformBrowser Platform = "Browser"
)

func (e *Platform) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Platform(s)
	case string:
		*e = Platform(s)
	default:
		return fmt.Errorf("unsupported scan type for Platform: %T", src)
	}
	return nil
}

type NullPlatform struct {
	Platform Platform
	Valid    bool // Valid is true if Platform is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlatform) Scan(value interface{}) error {
	if value == nil {
		ns.Platform, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Platform.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlatform) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Platform), nil
}

type Privacy string

const (
	PrivacyAll  Privacy = "all"
	PrivacyPsn  Privacy = "psn"
	PrivacyGame Privacy = "game"
)

func (e *Privacy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Privacy(s)
	case string:
		*e = Privacy(s)
	default:
		return fmt.Errorf("unsupported scan type for Privacy: %T", src)
	}
	return nil
}

type NullPrivacy struct {
	Privacy Privacy
	Valid   bool // Valid is true if Privacy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPrivacy) Scan(value interface{}) error {
	if value == nil {
		ns.Privacy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Privacy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPrivacy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Privacy), nil
}

type ResourceBackends string

const (
	ResourceBackendsFile  ResourceBackends = "file"
	ResourceBackendsPgLob ResourceBackends = "pg_lob"
	ResourceBackendsS3    ResourceBackends = "s3"
)

func (e *ResourceBackends) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResourceBackends(s)
	case string:
		*e = ResourceBackends(s)
	default:
		return fmt.Errorf("unsupported scan type for ResourceBackends: %T", src)
	}
	return nil
}

type NullResourceBackends struct {
	ResourceBackends ResourceBackends
	Valid            bool // Valid is true if ResourceBackends is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResourceBackends) Scan(value interface{}) error {
	if value == nil {
		ns.ResourceBackends, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResourceBackends.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResourceBackends) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResourceBackends), nil
}

type ResourceType string

const (
	ResourceTypeTEX ResourceType = "TEX"
	ResourceTypePLN ResourceType = "PLN"
	ResourceTypePNG ResourceType = "PNG"
	ResourceTypeJPG ResourceType = "JPG"
	ResourceTypeREC ResourceType = "REC"
	ResourceTypeFSH ResourceType = "FSH"
	ResourceTypeVOP ResourceType = "VOP"
	ResourceTypeLVL ResourceType = "LVL"
	ResourceTypeADC ResourceType = "ADC"
	ResourceTypeADS ResourceType = "ADS"
	ResourceTypeQST ResourceType = "QST"
	ResourceTypeCHK ResourceType = "CHK"
	ResourceTypeUNK ResourceType = "UNK"
)

func (e *ResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResourceType(s)
	case string:
		*e = ResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ResourceType: %T", src)
	}
	return nil
}

type NullResourceType struct {
	ResourceType ResourceType
	Valid        bool // Valid is true if ResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResourceType), nil
}

type SlotType string

const (
	SlotTypeDeveloper SlotType = "developer"
	SlotTypeUser      SlotType = "user"
	SlotTypeMoon      SlotType = "moon"
	SlotTypePod       SlotType = "pod"
	SlotTypeLocal     SlotType = "local"
)

func (e *SlotType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SlotType(s)
	case string:
		*e = SlotType(s)
	default:
		return fmt.Errorf("unsupported scan type for SlotType: %T", src)
	}
	return nil
}

type NullSlotType struct {
	SlotType SlotType
	Valid    bool // Valid is true if SlotType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSlotType) Scan(value interface{}) error {
	if value == nil {
		ns.SlotType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SlotType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSlotType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SlotType), nil
}

type Slottype string

const (
	SlottypePod        Slottype = "pod"
	SlottypeUser       Slottype = "user"
	SlottypeDeveloper  Slottype = "developer"
	SlottypeMoon       Slottype = "moon"
	SlottypeRemotemoon Slottype = "remotemoon"
	SlottypeLocal      Slottype = "local"
)

func (e *Slottype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Slottype(s)
	case string:
		*e = Slottype(s)
	default:
		return fmt.Errorf("unsupported scan type for Slottype: %T", src)
	}
	return nil
}

type NullSlottype struct {
	Slottype Slottype
	Valid    bool // Valid is true if Slottype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSlottype) Scan(value interface{}) error {
	if value == nil {
		ns.Slottype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Slottype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSlottype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Slottype), nil
}

type Config struct {
	Section pgtype.Text
	Config  []byte
}

type File struct {
	Hash string
	File pgtype.Uint32
}

type Heart struct {
	SlotID    pgtype.Int4
	Owner     pgtype.UUID
	HeartTime pgtype.Timestamp
}

type Photo struct {
	ID        int32
	Domain    int32
	Author    pgtype.UUID
	Small     string
	Medium    string
	Large     string
	Plan      string
	Slottype  Slottype
	Slotfield pgtype.Text
}

type PhotoSubject struct {
	PhotoID pgtype.Int4
	UserID  pgtype.UUID
	Name    pgtype.Text
	X1      pgtype.Int4
	Y1      pgtype.Int4
	X2      pgtype.Int4
	Y2      pgtype.Int4
}

type Resource struct {
	Hash         string
	ResourceType ResourceType
	Size         pgtype.Int8
	Created      pgtype.Timestamptz
	Uploader     pgtype.UUID
}

type ResourceOverride struct {
	Hash     string
	Override OverrideType
	Reason   pgtype.Text
}

type Room struct {
	ID          int32
	Players     []string
	Game        Game
	GameVersion string
	Platform    Platform
	RoomSlot    string
}

type Scoreboard struct {
	ID           uuid.UUID
	SlotID       pgtype.Int4
	AchievedTime pgtype.Timestamptz
	Score        pgtype.Int8
	Type         pgtype.Int4
	Players      []string
	MainPlayer   pgtype.UUID
	Platform     Platform
}

type Session struct {
	Userid   pgtype.UUID
	Ip       netip.Addr
	Token    uuid.UUID
	Game     Game
	Platform Platform
	Expiry   pgtype.Timestamp
}

type Slot struct {
	ID              int32
	Uploader        pgtype.UUID
	Name            pgtype.Text
	Description     pgtype.Text
	Icon            string
	RootLevel       string
	LocationX       pgtype.Int4
	LocationY       pgtype.Int4
	InitiallyLocked pgtype.Bool
	SubLevel        pgtype.Bool
	Lbp1only        pgtype.Bool
	Shareable       pgtype.Int4
	Background      pgtype.Text
	LevelType       pgtype.Text
	MinPlayers      pgtype.Int4
	MaxPlayers      pgtype.Int4
	MoveRequired    pgtype.Bool
	FirstPublished  pgtype.Timestamp
	LastUpdated     pgtype.Timestamp
	Domain          pgtype.Int4
	Game            int32
	Published       pgtype.Bool
}

type SlotResource struct {
	SlotID       pgtype.Int4
	ResourceHash pgtype.Text
}

type Thumb struct {
	SlotID      pgtype.Int4
	Owner       pgtype.UUID
	ThumbUpTime pgtype.Timestamp
	Down        pgtype.Bool
}

type User struct {
	ID                uuid.UUID
	Username          pgtype.Text
	AvatarHash        pgtype.Text
	PsnUid            string
	RpcnUid           string
	Bio               string
	CommentsEnabled   bool
	LocationX         int32
	LocationY         int32
	EntitledSlots     int32
	PlanetLbp2        pgtype.Text
	PlanetLbp3        pgtype.Text
	PlanetLbpVita     pgtype.Text
	PlanetCc          pgtype.Text
	BooIcon           pgtype.Text
	MehIcon           pgtype.Text
	YayIcon           pgtype.Text
	LevelVisibility   NullPrivacy
	ProfileVisibility NullPrivacy
}
